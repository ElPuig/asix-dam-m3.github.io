
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Lifecycle callbacks</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="mp08/p3"
                  title="Lifecycle callbacks"
                  environment="web"
                  feedback-link="https://github.com/gerardfp">
    
      <google-codelab-step label="Introducción" duration="0">
        <p>En esta práctica realizaremos diversos prototipos de aplicación con el objetivo de comprender los <strong><em>callbacks </em></strong><strong>del ciclo de vida</strong> de una aplicación.</p>
<p>A medida que el usuario navega, sale, y vuelve a una aplicación, las instancias <a href="https://developer.android.com/reference/android/app/Activity.html" target="_blank"><code>Activity</code></a> en la aplicación transitan entre los diferentes estados de su ciclo de vida. Por ejemplo, cuando la actividad se inicia por primera vez, esta viene al primer plano del sistema y recibe la atención al usuario. Durante este proceso, el Sistema Android llama a una serie de métodos del ciclo de vida de la actividad en los que se configura la interfaz de usuario y otros componentes. Si el usuario realiza una acción que inicia otra actividad o cambia a otra aplicación, el sistema llama a otro conjunto de métodos de ciclo de vida de la actividad mientras se envía al fondo (donde la actividad ya no es visible, pero la instancia y su estado se mantiene intacta).</p>
<p>Dentro de los métodos <em>callback</em> de ciclo de vida, se puede declarar cómo se comporta la actividad cuando los usuarios salen y vuelven a entrar en ella. Por ejemplo, si se está desarrollando un reproductor de vídeo streaming, es posible hacer una pausa en el vídeo y terminar la conexión de red cuando el usuario cambia a otra aplicación. Cuando el usuario vuelve, la apliación vuelve a conectarse a la red y permite al usuario reanudar el vídeo desde el mismo punto.</p>
<p>En esta práctica desarrollaremos una aplicación que registra (<em>log</em>) la actividad de la aplicación</p>
<p class="image-container"><img style="width: 315.00px" src="img\7575655a53724359.gif"></p>
<p>Encontrarás el código de la app aquí: <a href="https://github.com/gerardfp/P3" target="_blank">https://github.com/gerardfp/P3</a></p>


      </google-codelab-step>
    
      <google-codelab-step label="Comprender los callbacks del ciclo de vida" duration="0">
        <p>Una <a href="https://developer.android.com/reference/android/app/Activity.html" target="_blank"><code>Activity</code></a> puede estar en uno de estos tres estados:</p>
<table>
<tr><td colspan="1" rowspan="1"><p>Resumed</p>
</td><td colspan="1" rowspan="1"><p>En este estado, la actividad está en el <strong>primer plano</strong> y el usuario puede interactuar con ella.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Paused </p>
</td><td colspan="1" rowspan="1"><p>En este estado, la actividad está <strong>parcialmente oculta</strong> por otra actividad, la otra actividad que está en el primer plano es semitransparente o no cubre toda la pantalla. La actividad en pausa no recibe la entrada del usuario y no puede ejecutar ningún código. </p>
<p>Una actividad pausada está completamente &#34;viva&#34; (el objeto <a href="https://developer.android.com/reference/android/app/Activity.html" target="_blank">Activity</a> se conserva en la memoria, mantiene toda la información de estado y miembro y continúa anexado al administrador de ventanas), pero el sistema puede eliminarla en situaciones en que la memoria sea extremadamente baja.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Stopped </p>
</td><td colspan="1" rowspan="1"><p>En este estado, la actividad está <strong>completamente oculta</strong> y no visible para el usuario; se considera que está en &#34;segundo plano&#34;. </p>
<p>Una actividad detenida también permanece &#34;viva&#34; (el objeto <a href="https://developer.android.com/reference/android/app/Activity.html" target="_blank">Activity</a> se conserva en memoria, mantiene toda la información de estado y miembro, pero <em>no</em> está anexado al administrador de ventanas). Sin embargo, ya no está visible para el usuario y el sistema puede eliminarla cuando necesite memoria en alguna otra parte.</p>
</td></tr>
</table>
<p>Cuando una actividad entra y sale de los diferentes estados, esto se notifica a través de diferentes métodos callback. Todos los métodos callback son enlaces que puedes invalidar (<em>Override</em>) para realizar las tareas correspondientes cuando cambia el estado de la actividad.</p>
<p>El siguiente diagrama ilustra los camino que debe tomar una actividad entre estados. Los rectángulos grises representan los métodos callback que puedes implementar para realizar operaciones cuando la actividad cambie de estado.</p>
<p class="image-container"><img style="width: 736.10px" src="img\8e9d6a837ae06998.png"></p>
<h2 is-upgraded>Implementación de callbacks del ciclo de vida</h2>
<p>Para implementar los callbacks del ciclo de vida echaremos mano del autocompletado. Por ejemplo, para implementar el callback <code>onStart()</code> haremos:</p>
<p class="image-container"><img style="width: 598.00px" src="img\4e56ce996c8cec59.gif"></p>
<p>La siguiente actividad estructural incluye todos los métodos <em>callback </em>fundamentales del ciclo de vida.</p>
<pre><code>import android.content.Intent;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.TextView;

import java.time.LocalDateTime;

import androidx.appcompat.app.AppCompatActivity;

public class MainActivity extends AppCompatActivity {

   private static final String TAG = &#34;ABCD&#34;;
   TextView textView;

   @Override
   protected void onCreate(Bundle savedInstanceState) {
       super.onCreate(savedInstanceState);
       setContentView(R.layout.activity_main);

       Log.e(TAG,&#34;onCreate&#34;);

       textView = findViewById(R.id.textView);
       findViewById(R.id.dialog_button).setOnClickListener(new View.OnClickListener() {
           @Override
           public void onClick(View view) {
               startActivity(new Intent(MainActivity.this, DialogActivity.class));
           }
       });

       textView.setText(textView.getText() + &#34;\n&#34; + LocalDateTime.now() + &#34;: onCreate&#34;);
   }

   @Override
   protected void onStart() {
       super.onStart();
       Log.e(TAG,&#34;onStart&#34;);

       textView.setText(textView.getText() + &#34;\n&#34; + LocalDateTime.now() + &#34;: onStart&#34;);
   }

   @Override
   protected void onResume() {
       super.onResume();
       Log.e(TAG,&#34;onResume&#34;);

       textView.setText(textView.getText() + &#34;\n&#34; + LocalDateTime.now() + &#34;: onResume&#34;);
   }

   @Override
   protected void onPause() {
       super.onPause();
       Log.e(TAG,&#34;onPause&#34;);

       textView.setText(textView.getText() + &#34;\n&#34; + LocalDateTime.now() + &#34;: onPause&#34;);
   }

   @Override
   protected void onStop() {
       super.onStop();
       Log.e(TAG,&#34;onStop&#34;);

       textView.setText(textView.getText() + &#34;\n&#34; + LocalDateTime.now() + &#34;: onStop&#34;);
   }

   @Override
   protected void onRestart() {
       super.onRestart();
       Log.e(TAG,&#34;onRestart&#34;);

       textView.setText(textView.getText() + &#34;\n&#34; + LocalDateTime.now() + &#34;: onRestart&#34;);
   }

   @Override
   protected void onDestroy() {
       super.onDestroy();
       Log.e(TAG,&#34;onDestroy&#34;);

       textView.setText(textView.getText() + &#34;\n&#34; + LocalDateTime.now() + &#34;: onDestroy&#34;);
   }

   @Override
   public void onSaveInstanceState(Bundle outState) {
       super.onSaveInstanceState(outState);
       Log.e(TAG,&#34;onSaveInstanceState&#34;);

       textView.setText(textView.getText() + &#34;\n&#34; + LocalDateTime.now() + &#34;: onSaveInstanceState&#34;);
       outState.putString(&#34;REGISTRO&#34;, textView.getText().toString());
   }

   @Override
   protected void onRestoreInstanceState(Bundle savedInstanceState) {
       super.onRestoreInstanceState(savedInstanceState);
       Log.e(TAG,&#34;onRestoreInstanceState&#34;);

       textView.setText(savedInstanceState.getString(&#34;REGISTRO&#34;));
       textView.setText(textView.getText() + &#34;\n&#34; + LocalDateTime.now() + &#34;: onRestoreInstanceState&#34;);
   }
}</code></pre>
<p>La imlementación de cada uno de los callbacks incluye unas instrucciones para &#34;anotar&#34; el registro, tanto en un TextView, como en el Logcat de Android Studio.</p>
<aside class="special"><p><strong>Nota:</strong> La implementación que realices de estos métodos del ciclo de vida siempre deben llamar la implementación de la superclase antes de realizar cualquier otra tarea, como se muestra en los ejemplos anteriores.</p>
</aside>
<p>Ejecuta esta aplicación y observa el registro que se va mostrando en el TextView. Haz diferentes operaciones que cambien el estado de la  actividad para observar la sucesión de llamadas <em>callback </em>de la Activity que el Sistema Android va llamando durante las transiciones de estado. Por ejemplo:</p>
<ul>
<li>Pulsa el boton &#34;Atrás&#34;</li>
<li>Haz un rotación de pantalla</li>
<li>Bloquea y desbloquea el móvil</li>
<li>Inicia el selector de aplicaciones</li>
<li>Cierra la aplicación</li>
</ul>
<p>Observarás que la Activity transita entre los estados <strong>Resumed </strong>y <strong>Stopped</strong>, ejecutando lo sucesivos callbacks que conforman el camino entre ambos estados. Sin embargo, en ningún momento se habrá quedado en el estado <strong>Paused</strong>.</p>
<aside class="special"><p><strong>La variable </strong><strong><code>TAG</code></strong><strong> que hemos usado para el método </strong><strong><code>Log.e()</code></strong><strong> es para poder filtrar los mensajes del Logcat, de forma que nos muestre solo los que tengan el texto </strong><strong><code>&#34;ABCD&#34;</code></strong><strong>.</strong></p>
<p class="image-container"><img style="width: 689.00px" src="img\8da4fa2440dc9718.png"></p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Estado Paused" duration="0">
        <p>Una actividad permanece en estado <code>Paused</code> cuando otra actividad la <strong>oculta parcialmente</strong>.</p>
<p>Implementaremos un Activity (a modo de diálogo) que oculte parcialmente la <code>MainActivity</code>, y la mantenga en estado <code>Paused</code>:</p>
<ol type="1" start="1">
<li>Crea una nueva Activity con el nombre <code>DialogActivity<br></code></li>
<li>En el <code>AndroidManifest.xml</code> añade un atributo al elemento <code>&lt;Activity&gt;</code> que corresponde a la <code>DialogActivity</code>:</li>
</ol>
<pre><code>android:theme=&#34;@style/Theme.AppCompat.Dialog&#34;</code></pre>
<p class="image-container"><img style="width: 598.00px" src="img\48698f831df3eb59.gif"></p>
<ol type="1" start="3">
<li>Añade un <code>&lt;Button&gt;</code> al layout de la MainActivity (<code>activity_main.xml</code>). Este botón abrirá la DialogActivity.<br><br>Para que el <code>Button</code> y el <code>TextView</code> queden uno debajo del otro, utlitza un <code>LinearLayout</code> con la propiedad <strong><code>android:orientation=&#34;vertical&#34;</code></strong>.</li>
</ol>
<pre><code>&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34;
   android:layout_width=&#34;match_parent&#34;
   android:layout_height=&#34;match_parent&#34;&gt;

   &lt;LinearLayout
       android:layout_width=&#34;match_parent&#34;
       android:layout_height=&#34;match_parent&#34;
       android:orientation=&#34;vertical&#34;&gt;
       &lt;Button
           android:id=&#34;@+id/dialog_button&#34;
           android:layout_width=&#34;match_parent&#34;
           android:layout_height=&#34;wrap_content&#34;
           android:text=&#34;Open dialog&#34;/&gt;
       &lt;TextView
           android:id=&#34;@+id/textView&#34;
           android:layout_width=&#34;match_parent&#34;
           android:layout_height=&#34;match_parent&#34; /&gt;
   &lt;/LinearLayout&gt;

&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code></pre>
<ol type="1" start="4">
<li>Establece un <code>OnClickListener</code> al botón, para que abra el diálogo cuando se haga click sobre él. Para ello, ve al método <code>onCreate()</code> de la <code>MainActivity</code> y agrega el siguiente código:<br></li>
</ol>
<pre><code>findViewById(R.id.dialog_button).setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View view) {
        startActivity(new Intent(MainActivity.this, DialogActivity.class));
    }
});</code></pre>
<p><br>Ejecuta la aplicación y haz click sobre el botón. La <code>DialogActivity</code> se abrirá y ocultará parcialmente la <code>MainActivity</code>. El sistema ejecutará entonces el callback <code>onPause()</code> de la <code>MainActivity</code>, y ésta quedará en estado <strong>Paused </strong>hasta que se cierre el diálogo, momento en el que volverá al estado <em>Resumed</em>.</p>
<aside class="special"><p>Nota: Se pueden crear diálogos de múltiples formas en Android. Acabamos de ver una de ellas, que muestra una Activity con el <code>Theme.Dialog</code>, pero también se proveen clases específicas para crear diálogos.</p>
<p>Si tienes curiosidad sobre de qué otras formas se pueden crear diálogos, prueba ésta:</p>
<ul>
<li>Comenta el código que inicia la <code>DialogActivity</code> en listener del botón</li>
</ul>
<p><code>// startActivity(new Intent(MainActivity.this, DialogActivity.class))</code></p>
<ul>
<li>Añade el siguiente código para mostrar un <code>AlertDialog</code>:</li>
</ul>
<p><code>new AlertDialog.Builder(MainActivity.this).setMessage(&#34;hello&#34;).create().show();</code></p>
<p><strong>Observa que este tipo de diálogos no modifican el estado de la Activity que los lanza.</strong></p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Guardar el estado de una Actividad" duration="0">
        <p>El comportamiento predeterminado del sistema preserva el estado de una actividad cuando esta se detiene. De este modo, cuando los usuarios vuelven a una actividad anterior, su interfaz de usuario aparece como la habían dejado (por ejemplo, el texto introducido en un <code>EditText</code>).</p>
<p>Cuando el sistema detiene una actividad (por ejemplo, cuando se inicia una actividad nueva o la tarea pasa a segundo plano), <strong>es posible que el sistema destruya esa actividad</strong> completamente si necesita recuperar memoria del sistema. Cuando esto sucede, se pierde la información sobre el estado de la actividad. No obstante, Android implementa de forma predeterminada un sistema de guardado y recuperación de esta información.</p>
<p>El proceso automático de guardar el estado de una Activity consiste en almacenar en un objeto de clase <code>Bundle</code> la información de los elementos de la Interfaz de Usuario (<code>EditText</code>, <code>Checkbox</code>, <code>RadioButton</code>, etc.) antes de que la Activity sea destruida, para después restaurar esos valores cuando se vuelve a crear.</p>
<p>El guardado de datos tiene lugar en el método <code>onSaveInstanceState()</code>, y el de restauración en <code>onRestoreInstanceState()</code>.</p>
<p>El proceso automático de guardar y restaurar el estado de una Activity se realiza para la mayoria de elementos de Interfaz de Usuario que provee Android. <strong>Sin embargo, en algunos casos debemos ser nosotros los que hagamos este proceso de forma &#34;manual&#34;</strong>.</p>
<p>Observa qué ocurre cuando cambias la orientación del movil entre vertical y horizontal: el valor del TextView se pierde. Esto es debido a que cunado ocurre un cambio en la configuración (en este caso la orientación del móvil) el Sistema Android destruye y vuelve a crear la actividad.</p>
<p>El sistema automático de guardado y restauración de datos no ha guardado el text del <code>TextView</code>. Debemos hacerlo, pues, de forma manual nosotros mismos.</p>
<p>Para guardar el contenido del <code>TextView</code>, invalidaremos el método <code>onSaveInstanceState()</code>, de forma que además de ejecutar la implementación de la superclase (<strong>super</strong>), también nos guarde en el objeto <code>Bundle</code> el contenido del <code>TextView</code>.</p>
<p>Para restaurar, el procedimiento es el mismo, pero esta vez en el método <code>onRestoreInstanceState()</code>. Seguiremos llamando a la implementación de la superclase para que siga realizando el guardado automático, pero también añadiremos una instrucción para que restaure el contenido del <code>TextView</code> a partir del dato guardado en el objeto <code>Bundle</code>. </p>
<p>Hagámoslo:</p>
<ol type="1" start="1">
<li>Invalida los método <code>onSaveInstanceState()</code> y  <code>onRestoreInstanceState()</code> con el siguiente código:<br></li>
</ol>
<pre><code>@Override
public void onSaveInstanceState(Bundle outState) {
   super.onSaveInstanceState(outState);
   Log.e(TAG,&#34;onSaveInstanceState&#34;);

   textView.setText(textView.getText() + &#34;\n&#34; + LocalDateTime.now() + &#34;: onSaveInstanceState&#34;);
   outState.putString(&#34;REGISTRO&#34;, textView.getText().toString());
}

@Override
protected void onRestoreInstanceState(Bundle savedInstanceState) {
   super.onRestoreInstanceState(savedInstanceState);
   Log.e(TAG,&#34;onRestoreInstanceState&#34;);

   textView.setText(savedInstanceState.getString(&#34;REGISTRO&#34;));
   textView.setText(textView.getText() + &#34;\n&#34; + LocalDateTime.now() + &#34;: onRestoreInstanceState&#34;);
}</code></pre>
<p>La forma de almacenar valores en el objeto <code>Bundle</code> es mediante pares clave/valor. En este ejemplo hemos puesto la clave de forma literal (<strong><code>&#34;REGISTRO&#34;</code></strong>). Sería conveniente definir una constante en su lugar.</p>
<p>Observa sin embargo que el registro de los métodos <code>onStop</code>, <code>onDestroy</code>, <code>onCreate</code> y <code>onStart</code> no se quedan guardados en el TextView. Esto es debido a que el método <code>onSaveInstanceState</code> se llama justo después de <code>onPause</code> y el método <code>onRestoreInstanceState</code> se llama justo después de <code>onStart</code>.</p>
<h2 is-upgraded>El usuario presiona el botón &#34;Atrás&#34;</h2>
<p>Si una activity está en primer plano y el usuario presiona el botón &#34;Atrás&#34;, la Activity transita a través de los callbacks <code>onPause()</code>, <code>onStop()</code>, y <code>onDestroy()</code>. Además, el sistema finalizará la Aplicación, destruyendo el proceso de la Aplicación por completo.</p>
<p><strong>Es importante tener en cuenta que el callback </strong><strong><code>onSaveInstanceState()</code></strong><strong> no se lanza en este caso.</strong></p>
<p>Haz una prueba con la Aplicación anterior: introduce un texto y luego pulsa el botón &#34;Atrás&#34;. La aplicación se finalizará; si la abres de nuevo el texto habrá desaparecido.</p>
<p>Hay ocasiones en que éste es el comportamiento deseado para una aplicación, pero en muchas otras el usuario espera seguir teniendo la aplicación tal y como la dejó después de pulsar el botón &#34;Atrás&#34;. Para conseguir esto tenemos dos opciones:</p>
<ol type="1" start="1">
<li>Podemos simplemente invalidar el callback <code>onBackPressed()</code> (que es el método que se ejecuta cuando se pulsa el botón &#34;Atrás&#34;), para que en lugar de hacer la acción por defecto especificada en la superclase (que es finalizar la aplicación), envíe la aplicación a &#34;segundo plano&#34;.<br></li>
</ol>
<pre><code>@Override
public void onBackPressed() {
   moveTaskToBack(true);
}</code></pre>
<ol type="1" start="2">
<li>Dejar el comportamiento por defecto del botón &#34;Atrás&#34;. En tal caso, tendremos que guardar y restaurar el estado <strong>de forma persistente</strong>. Android provee diversos sistemas de almacenamiento persistente. Por ejemplo, ficheros y bases de datos. Esta vez, sin embargo, utilizaremos un mecanismo de guardado de datos persistente implementado en la clase <code>SharedPreferences</code>.<br><br>No te preocupes si ahora no entiendes del todo el funcionamiento de clase <code>SharedPreferences</code>, la veremos en otra práctica. De momento, vale con que entiendas que almacena datos usando pares clave/valor.<br><br>Implementemos la funcionalidad necesaria para que el contenido del <code>TextView</code> se alamacene y se restaure cuando la aplicación se cierre y se vuelva a abrir:</li>
</ol>
<ol type="1" start="1">
<li>Modifica el método <code>onDestroy()</code> para que almacene el estado del TextView en las <code>SharedPreferences</code>:<br></li>
</ol>
<pre><code>@Override
protected void onDestroy() {
   Log.e(TAG,&#34;onDestroy&#34;);

   textView.setText(textView.getText() + &#34;\n&#34; + LocalDateTime.now() + &#34;: onDestroy&#34;);

   getPreferences(MODE_PRIVATE)
           .edit()
           .putString(&#34;REGISTRO&#34;, textView.getText().toString())
           .apply();

   super.onDestroy();
}
</code></pre>
<ol type="1" start="2">
<li>Modifica <code>onCreate()</code> para que restaure el TextView con el estado guardado en las <code>SharedPreferences</code>:<br></li>
</ol>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
   super.onCreate(savedInstanceState);
   setContentView(R.layout.activity_main);


   Log.e(TAG,&#34;onCreate&#34;);

   textView = findViewById(R.id.textView);
  
   textView.setText(getPreferences(MODE_PRIVATE).getString(&#34;REGISTRO&#34;, &#34;&#34;));

   findViewById(R.id.dialog_button).setOnClickListener(new View.OnClickListener() {
       @Override
       public void onClick(View view) {
           startActivity(new Intent(MainActivity.this, DialogActivity.class));
       }
   });

   textView.setText(textView.getText() + &#34;\n&#34; + LocalDateTime.now() + &#34;: onCreate&#34;);
}</code></pre>
<ol type="1" start="3">
<li>Elimina los métodos <code>onSaveInstanceState()</code> y <code>onRestoreInstanceState()</code>, ya que ahora el estado se guarda en de forma persistente en las <code>SharedPreferences</code> y no en el <code>Bundle</code>.</li>
</ol>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>

</body>
</html>
