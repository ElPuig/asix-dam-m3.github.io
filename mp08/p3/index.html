
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Lifecycle callbacks</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="mp08/p3"
                  title="Lifecycle callbacks"
                  environment="web"
                  feedback-link="https://github.com/gerardfp">
    
      <google-codelab-step label="Introducción" duration="0">
        <p>En esta práctica realizaremos diversos prototipos de aplicación con el objetivo de comprender los <strong><em>callbacks </em></strong><strong>del ciclo de vida</strong> de una aplicación.</p>
<p>A medida que el usuario navega, sale, y vuelve a una aplicación, las instancias <a href="https://developer.android.com/reference/android/app/Activity.html" target="_blank"><code>Activity</code></a> en la aplicación transitan entre los diferentes estados de su ciclo de vida. Por ejemplo, cuando la actividad se inicia por primera vez, esta viene al primer plano del sistema y recibe la atención al usuario. Durante este proceso, el Sistema Android llama a una serie de métodos del ciclo de vida de la actividad en los que se configura la interfaz de usuario y otros componentes. Si el usuario realiza una acción que inicia otra actividad o cambia a otra aplicación, el sistema llama a otro conjunto de métodos de ciclo de vida de la actividad mientras se envía al fondo (donde la actividad ya no es visible, pero la instancia y su estado se mantiene intacta).</p>
<p>Dentro de los métodos <em>callback</em> de ciclo de vida, se puede declarar cómo se comporta la actividad cuando los usuarios salen y vuelven a entrar en ella. Por ejemplo, si se está desarrollando un reproductor de vídeo streaming, es posible hacer una pausa en el vídeo y terminar la conexión de red cuando el usuario cambia a otra aplicación. Cuando el usuario vuelve, la apliación vuelve a conectarse a la red y permite al usuario reanudar el vídeo desde el mismo punto.</p>
<p>En esta práctica desarrollaremos una aplicación que registra (<em>log</em>) la actividad de la aplicación</p>
<p class="image-container"><img style="width: 315.00px" src="img\7575655a53724359.gif"></p>
<p>Encontrarás el código de la app aquí: <a href="https://github.com/gerardfp/P3" target="_blank">https://github.com/gerardfp/P3</a></p>


      </google-codelab-step>
    
      <google-codelab-step label="Comprender los callbacks del ciclo de vida" duration="0">
        <p>Una <a href="https://developer.android.com/reference/android/app/Activity.html" target="_blank"><code>Activity</code></a> puede estar en uno de estos tres estados:</p>
<table>
<tr><td colspan="1" rowspan="1"><p>Resumed</p>
</td><td colspan="1" rowspan="1"><p>En este estado, la actividad está en el <strong>primer plano</strong> y el usuario puede interactuar con ella.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Paused </p>
</td><td colspan="1" rowspan="1"><p>En este estado, la actividad está <strong>parcialmente oculta</strong> por otra actividad, la otra actividad que está en el primer plano es semitransparente o no cubre toda la pantalla. La actividad en pausa no recibe la entrada del usuario y no puede ejecutar ningún código. </p>
<p>Una actividad pausada está completamente &#34;viva&#34; (el objeto <a href="https://developer.android.com/reference/android/app/Activity.html" target="_blank">Activity</a> se conserva en la memoria, mantiene toda la información de estado y miembro y continúa anexado al administrador de ventanas), pero el sistema puede eliminarla en situaciones en que la memoria sea extremadamente baja.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Stopped </p>
</td><td colspan="1" rowspan="1"><p>En este estado, la actividad está <strong>completamente oculta</strong> y no visible para el usuario; se considera que está en &#34;segundo plano&#34;. </p>
<p>Una actividad detenida también permanece &#34;viva&#34; (el objeto <a href="https://developer.android.com/reference/android/app/Activity.html" target="_blank">Activity</a> se conserva en memoria, mantiene toda la información de estado y miembro, pero <em>no</em> está anexado al administrador de ventanas). Sin embargo, ya no está visible para el usuario y el sistema puede eliminarla cuando necesite memoria en alguna otra parte.</p>
</td></tr>
</table>
<p>Cuando una actividad entra y sale de los diferentes estados, esto se notifica a través de diferentes métodos callback. Todos los métodos callback son enlaces que puedes invalidar (<em>Override</em>) para realizar las tareas correspondientes cuando cambia el estado de la actividad.</p>
<p>El siguiente diagrama ilustra los camino que debe tomar una actividad entre estados. Los rectángulos grises representan los métodos callback que puedes implementar para realizar operaciones cuando la actividad cambie de estado.</p>
<p class="image-container"><img style="width: 736.10px" src="img\8e9d6a837ae06998.png"></p>
<h2 is-upgraded>Implementación de callbacks del ciclo de vida</h2>
<p>La siguiente actividad estructural incluye todos los métodos <em>callback </em>fundamentales del ciclo de vida.</p>
<pre><code>import android.content.Intent;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.TextView;

import java.time.LocalDateTime;

import androidx.appcompat.app.AppCompatActivity;

public class MainActivity extends AppCompatActivity {

   private static final String TAG = &#34;ABCD&#34;;
   TextView textView;

   @Override
   protected void onCreate(Bundle savedInstanceState) {
       super.onCreate(savedInstanceState);
       setContentView(R.layout.activity_main);

       Log.e(TAG,&#34;onCreate&#34;);

       textView = findViewById(R.id.textView);
       findViewById(R.id.dialog_button).setOnClickListener(new View.OnClickListener() {
           @Override
           public void onClick(View view) {
               startActivity(new Intent(MainActivity.this, DialogActivity.class));
           }
       });

       textView.setText(textView.getText() + &#34;\n&#34; + LocalDateTime.now() + &#34;: onCreate&#34;);
   }

   @Override
   protected void onStart() {
       super.onStart();
       Log.e(TAG,&#34;onStart&#34;);

       textView.setText(textView.getText() + &#34;\n&#34; + LocalDateTime.now() + &#34;: onStart&#34;);
   }

   @Override
   protected void onResume() {
       super.onResume();
       Log.e(TAG,&#34;onResume&#34;);

       textView.setText(textView.getText() + &#34;\n&#34; + LocalDateTime.now() + &#34;: onResume&#34;);
   }

   @Override
   protected void onPause() {
       super.onPause();
       Log.e(TAG,&#34;onPause&#34;);

       textView.setText(textView.getText() + &#34;\n&#34; + LocalDateTime.now() + &#34;: onPause&#34;);
   }

   @Override
   protected void onStop() {
       super.onStop();
       Log.e(TAG,&#34;onStop&#34;);

       textView.setText(textView.getText() + &#34;\n&#34; + LocalDateTime.now() + &#34;: onStop&#34;);
   }

   @Override
   protected void onRestart() {
       super.onRestart();
       Log.e(TAG,&#34;onRestart&#34;);

       textView.setText(textView.getText() + &#34;\n&#34; + LocalDateTime.now() + &#34;: onRestart&#34;);
   }

   @Override
   protected void onDestroy() {
       super.onDestroy();
       Log.e(TAG,&#34;onDestroy&#34;);

       textView.setText(textView.getText() + &#34;\n&#34; + LocalDateTime.now() + &#34;: onDestroy&#34;);
   }

   @Override
   public void onSaveInstanceState(Bundle outState) {
       super.onSaveInstanceState(outState);
       Log.e(TAG,&#34;onSaveInstanceState&#34;);

       textView.setText(textView.getText() + &#34;\n&#34; + LocalDateTime.now() + &#34;: onSaveInstanceState&#34;);
       outState.putString(&#34;REGISTRO&#34;, textView.getText().toString());
   }

   @Override
   protected void onRestoreInstanceState(Bundle savedInstanceState) {
       super.onRestoreInstanceState(savedInstanceState);
       Log.e(TAG,&#34;onRestoreInstanceState&#34;);

       textView.setText(savedInstanceState.getString(&#34;REGISTRO&#34;));
       textView.setText(textView.getText() + &#34;\n&#34; + LocalDateTime.now() + &#34;: onRestoreInstanceState&#34;);
   }
}</code></pre>
<p>La imlementación de cada uno de los callbacks incluye unas instrucciones para &#34;anotar&#34; el registro, tanto en un TextView, como en el Logcat de Android Studio.</p>
<aside class="special"><p><strong>Nota:</strong> La implementación que realices de estos métodos del ciclo de vida siempre deben llamar la implementación de la superclase antes de realizar cualquier otra tarea, como se muestra en los ejemplos anteriores.</p>
</aside>
<p>Ejecuta esta aplicación y observa el registro que se va mostrando en el TextView. Haz diferentes operaciones que cambien el estado de la  actividad para observar la sucesión de llamadas <em>callback </em>de la Activity que el Sistema Android va llamando durante las transiciones de estado. Por ejemplo:</p>
<ul>
<li>Pulsa el boton &#34;Atrás&#34;</li>
<li>Haz un rotación de pantalla</li>
<li>Bloquea y desbloquea el móvil</li>
<li>Inicia el selector de aplicaciones</li>
<li>Cierra la aplicación</li>
</ul>
<p>Observarás que la Activity transita entre los estados <strong>Resumed </strong>y <strong>Stopped</strong>, ejecutando lo sucesivos callbacks que conforman el camino entre ambos estados. Sin embargo, en ningún momento se habrá quedado en el estado <strong>Paused</strong>.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Estado Paused" duration="0">
        <p>Una actividad permanece en estado <code>Paused</code> cuando otra actividad la <strong>oculta parcialmente</strong>.</p>
<p>Implementaremos un Activity (a modo de diálogo) que oculte parcialmente la <code>MainActivity</code>, y la mantenga en estado <code>Paused</code>:</p>
<ol type="1" start="1">
<li>Crea una nueva Activity con el nombre <code>DialogActivity<br></code></li>
<li>En el <code>AndroidManifest.xml</code> añade un atributo al elemento <a href="https://developer.android.com/guide/topics/manifest/activity-element.html" target="_blank"><code>&lt;</code><code>A</code><code>ctivi</code><code>ty</code><code>&gt;</code></a> que corresponde a la <code>DialogActivity</code>:</li>
</ol>
<pre><code>android:theme=&#34;@style/Theme.AppCompat.Dialog&#34;</code></pre>
<p class="image-container"><img style="width: 598.00px" src="img\48698f831df3eb59.gif"></p>
<ol type="1" start="3">
<li>Añade un <code>&lt;Button&gt;</code> al layout de la MainActivity (<code>activity_main.xml</code>). Este botón abrirá la DialogActivity.<br><br>Para que el <code>Button</code> y el <code>TextView</code> queden uno debajo del otro, utlitza un <code>LinearLayout</code> con la propiedad <strong><code>android:orientation=&#34;vertical&#34;</code></strong>.</li>
</ol>
<pre><code>&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34;
   android:layout_width=&#34;match_parent&#34;
   android:layout_height=&#34;match_parent&#34;&gt;

   &lt;LinearLayout
       android:layout_width=&#34;match_parent&#34;
       android:layout_height=&#34;match_parent&#34;
       android:orientation=&#34;vertical&#34;&gt;
       &lt;Button
           android:id=&#34;@+id/dialog_button&#34;
           android:layout_width=&#34;match_parent&#34;
           android:layout_height=&#34;wrap_content&#34;
           android:text=&#34;Open dialog&#34;/&gt;
       &lt;TextView
           android:id=&#34;@+id/textView&#34;
           android:layout_width=&#34;match_parent&#34;
           android:layout_height=&#34;match_parent&#34; /&gt;
   &lt;/LinearLayout&gt;

&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code></pre>
<ol type="1" start="4">
<li>Establece un <code>OnClickListener</code> al botón, para que abra el diálogo cuando se haga click sobre él. Para ello, ve al método <code>onCreate()</code> de la <code>MainActivity</code> y agrega el siguiente código:<br></li>
</ol>
<pre><code>findViewById(R.id.dialog_button).setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View view) {
        startActivity(new Intent(MainActivity.this, DialogActivity.class));
    }
});</code></pre>
<p><br>Ejecuta la aplicación y haz click sobre el botón. La <code>DialogActivity</code> se abrirá y ocultará parcialmente la <code>MainActivity</code>. El sistema ejecutará entonces el callback <code>onPause()</code> de la <code>MainActivity</code>, y ésta quedará en estado <em>Paused </em>hasta que se cierre el diálogo, momento en el que volverá al estado <em>Resumed</em>.</p>
<aside class="special"><p><strong>Nota:</strong> Se pueden crear diálogos de múltiples formas en Android. Acabamos de ver una de ellas, que muestra una Activity con el Theme.Dialog, pero también se proveen clases específicas para crear diálogos.</p>
<p><em>Si tienes curiosidad</em> sobre de qué otras formas se pueden crear diálogos, prueba ésta:</p>
<ul>
<li>Elimina el código que inicia la <code>DialogActivity</code> y añade el siguiente código para abrir un <code>AlertDialog</code>:<br></li>
</ul>
<p><em><code>// startActivity(new Intent(MainActivity.this, DialogActivity.class));</code></em></p>
<p><code>new AlertDialog.Builder(MainActivity.this).setTitle(&#34;Dialog&#34;).setMessage(&#34;hello&#34;).create().show();</code></p>
<p><strong>Observa que este tipo de diálogos no modifican el estado de la Activity que los lanza.</strong></p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Guardar el estado de una Actividad" duration="0">
        <p>El comportamiento predeterminado del sistema preserva el estado de una actividad cuando esta se detiene. De este modo, cuando los usuarios vuelven a una actividad anterior, su interfaz de usuario aparece como la habían dejado (por ejemplo, el texto introducido en un <code>EditText</code>). Sin embargo, tú puedes (y <strong>debes</strong>) retener de manera proactiva el estado de tus actividades utilizando métodos de callback, en caso de que la actividad se destruya y sea necesario volver a crearla.</p>
<p>Cuando el sistema detiene una actividad (por ejemplo, cuando se inicia una actividad nueva o la tarea pasa a segundo plano), es posible que el sistema destruya esa actividad completamente si necesita recuperar memoria del sistema. Cuando esto sucede, se pierde la información sobre el estado de la actividad. No obstante, Android implementa de forma predeterminada un sistema de guardado y recuperación de esta información.</p>
<p>El proceso automático de guardar el estado de una Activity consiste en almacenar en un objeto de clase <code>Bundle</code> la información de los elementos de la Interfaz de Usuario (<code>EditText</code>, <code>Checkbox</code>, <code>RadioButton</code>, etc.) antes de que la Activity sea destruida, para después restaurar esos valores cuando se vuelve a crear.</p>
<p>El guardado de datos tiene lugar en el método <code>onSaveInstanceState()</code>, y el de restauración en <code>onRestoreInstanceState()</code>.</p>
<p>Observemos las llamadas que el sistema realiza a estos métodos de nuestra Activity:</p>
<ol type="1" start="1">
<li>Anula los métodos <code>onSaveInstanceState()</code> y <code>onRestoreInstanceState()</code>, de la clase <code>MainActivity</code>, de forma que sigan ejecutando los métodos originales de la superclase (llamando a <strong>super</strong>), pero añade antes una instrucción para que muestren un <code>Toast</code>.<br></li>
</ol>
<pre><code>@Override
protected void onSaveInstanceState(Bundle savedInstanceState){
   Toast.makeText(this, &#34;onSaveInstanceState&#34;, Toast.LENGTH_SHORT).show();
   super.onSaveInstanceState(savedInstanceState);
}

@Override
protected void onRestoreInstanceState(Bundle savedInstanceState){
   Toast.makeText(this, &#34;onRestoreInstanceState&#34;, Toast.LENGTH_SHORT).show();
   super.onRestoreInstanceState(savedInstanceState);
}</code></pre>
<ol type="1" start="2">
<li>Añade un <code>&lt;EditText&gt;</code> al layout <code>activity_main.xml</code>:<br></li>
</ol>
<pre><code>&lt;EditText
   android:layout_width=&#34;match_parent&#34;
   android:layout_height=&#34;wrap_content&#34;
   android:id=&#34;@+id/edit_text&#34;/&gt;</code></pre>
<p><br>Ejecuta la aplicación. Introduce un texto en el <code>EditText</code>. Observa que al rotar la pantalla del móvil, el sistema destruye la Activity, y a continuación la vuelve a crear. No obstante el texto introducido en el <code>EditText</code> ha sido guardado y resturado automáticamente en los métodos correspondientes.</p>
<p>Si comentas la llamada al método <code>onSaveInstanceState()</code> de la superclase <code>Activity</code> (o <code>AppCompatActivity</code>), y ejecutas la aplicación, observarás que ya no se guarda el estado del <code>EditText</code> cuando al rotar la pantalla se destruya y se vuelva a crear la Actividad.</p>
<h2 is-upgraded>Guardar manualmente el estado de una Actividad</h2>
<p>El proceso automático de guardar y restaurar el estado de una Activity se realiza para la mayoria de elementos de Interfaz de Usuario que provee Android. Sin embargo, en algunos casos debemos ser nosotros los que hagamos este proceso de forma &#34;manual&#34;.</p>
<p>Veamos un ejemplo en el que no se guarda el estado de un elemento de la aplicación.</p>
<p>Desarrollaremos una aplicación con un <code>TextView</code>, un <code>EditText</code> y un <code>Button</code>: el usuario introducirá un texto en el campo de texto y cuando pulse el botón, el texto introducido aparecerá en el TextView.</p>
<ol type="1" start="1">
<li>Coloca los siguientes elementos en layout <code>activity_main.xml</code>:<br></li>
</ol>
<pre><code>&lt;LinearLayout
   android:layout_width=&#34;match_parent&#34;
   android:layout_height=&#34;wrap_content&#34;
   android:orientation=&#34;vertical&#34;&gt;
   &lt;TextView
       android:layout_width=&#34;wrap_content&#34;
       android:layout_height=&#34;wrap_content&#34;
       android:id=&#34;@+id/text_view&#34;/&gt;
   &lt;EditText
       android:layout_width=&#34;match_parent&#34;
       android:layout_height=&#34;wrap_content&#34;
       android:id=&#34;@+id/edit_text&#34;/&gt;
   &lt;Button
       android:layout_width=&#34;wrap_content&#34;
       android:layout_height=&#34;wrap_content&#34;
       android:text=&#34;Set Text&#34;
       android:id=&#34;@+id/button&#34;/&gt;
&lt;/LinearLayout&gt;</code></pre>
<ol type="1" start="2">
<li>Añade un listener al botón, en el callback <code>onCreate()</code>, para que establezca el texto del <code>EditText</code> en el <code>TextView</code>:<br></li>
</ol>
<pre><code>findViewById(R.id.button).setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View view) {
        ((TextView) findViewById(R.id.text_view)).setText(((EditText) findViewById(R.id.edit_text)).getText().toString());
    }
});</code></pre>
<p>Ejecuta la aplicación. Introduce un texto y pulsa el botón. El texto aparece en el <code>TextView</code>. Pero, si rotas la pantalla el texto desaparece.</p>
<p>El sistema automático de guardado y restauración de datos no ha guardado el text del <code>TextView</code>. Debemos hacerlo, pues, de forma manual nosotros mismos.</p>
<p>Para guardar el contenido del <code>TextView</code>, invalidaremos el método <code>onSaveInstanceState()</code>, de forma que además de ejecutar la implementación de la superclase (<strong>super</strong>), también nos guarde en el objeto <code>Bundle</code> el contenido del <code>TextView</code>.</p>
<p>Para restaurar, el procedimiento es el mismo, pero esta vez en el método <code>onRestoreInstanceState()</code>. Seguiremos llamando a la implementación de la superclase para que siga realizando el guardado automático, pero también añadiremos una instrucción para que restaure el contenido del <code>TextView</code> a partir del dato guardado en el objeto <code>Bundle</code>. </p>
<p>Hagámoslo:</p>
<ol type="1" start="1">
<li>Invalida el método <code>onSaveInstanceState()</code> con el siguiente código:<br></li>
</ol>
<pre><code>@Override
protected void onSaveInstanceState(Bundle savedInstanceState){
    super.onSaveInstanceState(savedInstanceState);
    savedInstanceState.putString(&#34;TextViewContent&#34;,  ((TextView) findViewById(R.id.text_view)).getText().toString());
}</code></pre>
<ol type="1" start="2">
<li>Invalida el método <code>onRestoreInstanceState()</code>:<br></li>
</ol>
<pre><code>@Override
protected void onRestoreInstanceState(Bundle savedInstanceState){
    super.onRestoreInstanceState(savedInstanceState);
    ((TextView) findViewById(R.id.text_view)).setText(savedInstanceState.getString(&#34;TextViewContent&#34;));
}</code></pre>
<p>La forma de almacenar valores en el objeto <code>Bundle</code> es mediante pares clave/valor. En este ejemplo hemos puesto la clave de forma literal. Sería conveniente definir una constante en su lugar.</p>
<h2 is-upgraded>El usuario presiona el botón &#34;Atrás&#34;</h2>
<p>Si una activity está en primer plano y el usuario presiona el botón &#34;Atrás&#34;, la Activity transita a través de los callbacks <code>onPause()</code>, <code>onStop()</code>, y <code>onDestroy()</code>. Además, el sistema finalizará la Aplicación, destruyendo el proceso de la Aplicación por completo.</p>
<p>Es importante tener en cuenta que el callback <code>onSaveInstanceState()</code> no se lanza en este caso.</p>
<p>Haz una prueba con la Aplicación anterior: introduce un texto y luego pulsa el botón &#34;Atrás&#34;. La aplicación se finalizará; si la abres de nuevo el texto habrá desaparecido.</p>
<p>Hay ocasiones en que éste es el comportamiento deseado para una aplicación, pero en muchas otras el usuario espera seguir teniendo la aplicación tal y como la dejó después de pulsar el botón &#34;Atrás&#34;. Para conseguir esto tenemos dos opciones:</p>
<ol type="1" start="1">
<li>Podemos simplemente invalidar el callback <code>onBackPressed()</code> (que es el método que se ejecuta cuando se pulsa el botón &#34;Atrás&#34;), para que en lugar de hacer la acción por defecto especificada en la superclase (que es finalizar la aplicación), envíe la aplicación a &#34;segundo plano&#34;.<br></li>
</ol>
<pre><code>@Override
public void onBackPressed() {
   moveTaskToBack(true);
}</code></pre>
<ol type="1" start="2">
<li>Dejar el comportamiento por defecto del botón &#34;Atrás&#34;. En tal caso, tendremos que guardar y restaurar el estado de forma pesistente. Android provee diversos sistemas de almacenamiento persistente. Por ejemplo, ficheros y bases de datos. Esta vez, sin embargo, utilizaremos un mecanismo de guardado de datos persistente implementado en la clase <code>SharedPreferences</code>.<br><br>No te preocupes si ahora no entiendes del todo el funcionamiento de clase <code>SharedPreferences</code>, la veremos en otra práctica. De momento, vale con que entiendas que almacena datos usando pares clave/valor.<br><br>Implementemos la funcionalidad necesaria para que el contenido del <code>TextView</code> se alamacene y se restaure cuando la aplicación se cierre y se vuelva a abrir:</li>
</ol>
<ol type="1" start="1">
<li>Implementa dos métodos en la clase <code>MainActivity</code>, uno que guarde el estado del <code>TextView</code> en las <code>SharedPreferences</code>, y otro que lo restaure.<br></li>
</ol>
<pre><code>private void saveState(){
    getPreferences(MODE_PRIVATE).edit()
            .putString(&#34;TextViewContent&#34;, ((TextView) findViewById(R.id.text_view)).getText().toString())
            .apply();
}

private void restoreState(){
    ((TextView) findViewById(R.id.text_view)).setText(getPreferences(MODE_PRIVATE).getString(&#34;TextViewContent&#34;, &#34;&#34;));
}</code></pre>
<ol type="1" start="2">
<li>Añade la llamada al método <code>saveState()</code> al callback <code>onPause()</code>:<br></li>
</ol>
<pre><code>@Override
protected void onPause() {
    saveState();
    super.onPause();
}</code></pre>
<ol type="1" start="3">
<li>Añade la llamada al método <code>restoreState()</code> al callback <code>onCreate()</code>:<br></li>
</ol>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    restoreState();

    // ...other actions...
}</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Tarea" duration="0">
        <p>Desarrolla una Aplicación que muestre un registro del Ciclo de Vida de su Actividad Principal.</p>
<p>Cada vez que se llame a un callback del ciclo de vida de la <code>MainActivity</code>, se debe mostrar en la pantalla un registro con el nombre del callback que se ha llamado y la hora en que se ha hecho.</p>
<p>Para mostrar el registro, puedes utilizar un <code>LinearLayout</code> en el que se vaya añadiendo un <code>TextView</code> por cada entrada del registro.</p>
<p>No es necesario que el registro se mantenga cuando se cierre la aplicación y se vuelva a abrir, ni tampoco cuando la Activity se destruya y se vuelva a crear (por ejemplo al rotar el teléfono).</p>
<p class="image-container"><img style="width: 267.00px" src="img\baac151008eeae9c.png"></p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>

</body>
</html>
