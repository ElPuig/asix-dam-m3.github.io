<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<script type="module" src="/sofi/js/script.js"></script>
<link rel="stylesheet" href="/sofi/css/estil.css">

<nav></nav>
<header>
  <h1>RecyclerView</h1>
  <abstract>
    <p><a href="https://developer.android.com/topic/libraries/architecture/livedata">RecyclerView</a> es un widget para mostrar una lista de elemenos.</p>

    <p>Desarrollaremos una app que muestra una lista de <strong>elementos genéricos</strong>, y que permite añadir, ver o eliminar un elemento.</p>

    <img src="img/recyclerview.gif"/>

    <a href="https://github.com/gerardfp/RecyclerView">https://github.com/gerardfp/RecyclerView</a>
  </abstract>
</header>

<section>
    <h2>Crea el proyecto</h2>

    <p>Clona (o descarga) este repositorio: <a href="https://github.com/gerardfp/RecyclerView_template">https://github.com/gerardfp/RecyclerView_template</a></p>
    
    <p>Esta plantilla de proyecto incorpora lo siguiente:</p>

    <ul>
        <li>Se ha configurado el ViewBinding</li>
        <li>
            <p>Se ha configurado la navegación con las siguientes <strong>Views</strong>:</p>

            <ul>
                <li><p><w>MostrarElementoFragment</w>: Muestra el detalle de un Elemento</p></li>
                <li><p><w>NuevoElementoFragment</w>: Permite introducir los datos y añadir un nuevo Elemento a la lista</p></li>
                <li>
                    <p><w>RecyclerElementosFragment</w>: Muestra la lista de todos los Elementos. 
                        También tiene un <w>FloatingActionButton</w>, que permite navegar hacia el NuevoElementoFragment.</p>
                </li>
            </ul>
        
            <img src="img/rv_nav_graph.png">        
        </li>
        <li>
            <p>Se ha añadido un <strong>Model</strong> para almacenar la lista de elementos:</p>

            <p>La classe <w>Elemento</w> simplemente es para contener los datos de un elemento.</p>
            <scfile>
                Elemento.java
            </scfile>
            <sc java>
                public class Elemento {
                    String nombre;
                    String descripcion;
                    float valoracion;
                
                    public Elemento(String nombre, String descripcion) {
                        this.nombre = nombre;
                        this.descripcion = descripcion;
                    }
                }                
            </sc>

            <p>La clase <w>ElementosRepositorio</w> mantiene la lista de elementos en un <w>ArrayList</w>:</p>
            <ul>
                <li><p>En el constructor se añaden algunos elementos de ejemplo.</p></li>
                <li><p>Tiene dos métodos para <w>anyadir()</w> o <w>eliminar()</w> un elemento, que retornan en un <em>callback</em>, 
                    el <w>ArrayList</w> de elementos resultante.</p></li>
            </ul>
            
            
            <scfile>
                ElementosRepositorio.java
            </scfile>
            <sc java>
                import java.util.ArrayList;
                import java.util.List;

                public class ElementosRepositorio {

                    List&lt;Elemento&gt; elementos = new ArrayList&lt;&gt;();

                    interface Callback {
                        void cuandoFinalice(List&lt;Elemento&gt; elementos);
                    }

                    ElementosRepositorio(){
                        elementos.add(new Elemento(&quot;Elemento químico&quot;, &quot;Es un átomo con moléculas, aquella sustancia que no puede ser descompuesta mediante una reacción química, en otras más simples. Pueden existir dos átomos de un mismo elemento con características distintas y, en el caso de que estos posean número másico distinto, pertenecen al mismo elemento pero en lo que se conoce como uno de sus isótopos.&quot;));
                        elementos.add(new Elemento(&quot;Elemento de un conjunto&quot;, &quot;En teoría de conjuntos, un elemento o miembro de un conjunto (o familia de conjuntos) es un objeto que forma parte de ese conjunto (o familia).&quot;));
                        elementos.add(new Elemento(&quot;Elemento sintético&quot;, &quot;En química, un elemento sintético es un elemento químico que no aparece de forma natural en la Tierra, y solo puede ser creado artificialmente.&quot;));
                        elementos.add(new Elemento(&quot;Elemento algebraico&quot;, &quot;En matemáticas, más concretamente en álgebra abstracta y teoría de cuerpos, se dice que un elemento es algebraico sobre un cuerpo si es raíz de algún polinomio con coeficientes en dicho cuerpo. Los elementos algebraicos sobre el cuerpo de los números racionales reciben el nombre de números algebraicos.&quot;));
                        elementos.add(new Elemento(&quot;Elementos de la naturaleza&quot;,&quot;Los cuatro o cinco elementos de la naturaleza —normalmente agua, tierra, fuego y aire, a los que se añade la quintaesencia o éter— eran, para muchas doctrinas antiguas, los constituyentes básicos de la materia y explicaban el comportamiento de la naturaleza. El modelo estuvo vigente hasta que la ciencia moderna empezó a desentrañar los elementos y reacciones químicas.&quot;));
                        elementos.add(new Elemento(&quot;Elemento constructivo&quot;,&quot;Un elemento constructivo es cada uno de los componentes materiales que integran una obra de construcción. Se suelen clasificar en estructurales y compartimentadores.&quot;));
                    }

                    void anyadir(Elemento elemento, Callback callback){
                        elementos.add(elemento);
                        callback.cuandoFinalice(elementos);
                    }

                    void eliminar(int posicion, Callback callback) {
                        elementos.remove(posicion);
                        callback.cuandoFinalice(elementos);
                    }
                }
            </sc>
        </li>

        <li>
            <p>Se ha creado un <w>ViewModel</w> que expone las acciones sobre el modelo (añadir y eliminar), guardando
            la lista de elementos en un <w>MutableLiveData</w> que pueda ser observado por las vistas.</p>

            <scfile>
                ElementosViewModel.java
            </scfile>
            <sc java>
                import android.app.Application;

                import androidx.annotation.NonNull;
                import androidx.lifecycle.AndroidViewModel;
                import androidx.lifecycle.MutableLiveData;

                import java.util.List;

                public class ElementosViewModel extends AndroidViewModel {

                    ElementosRepositorio elementosRepositorio;

                    MutableLiveData&lt;List&lt;Elemento&gt;&gt; listaElementos = new MutableLiveData&lt;&gt;();

                    public ElementosViewModel(@NonNull Application application) {
                        super(application);

                        elementosRepositorio = new ElementosRepositorio();

                        listaElementos.setValue(elementosRepositorio.elementos);
                    }

                    MutableLiveData&lt;List&lt;Elemento&gt;&gt; obtenerListaElementos(){
                        return listaElementos;
                    }

                    void anyadirElemento(Elemento elemento){
                        elementosRepositorio.anyadir(elemento, new ElementosRepositorio.Callback() {
                            @Override
                            public void cuandoFinalice(List&lt;Elemento&gt; elementos) {
                                listaElementos.setValue(elementos);
                            }
                        });
                    }

                    void eliminarElemento(int posicion){
                        elementosRepositorio.eliminar(posicion, new ElementosRepositorio.Callback() {
                            @Override
                            public void cuandoFinalice(List&lt;Elemento&gt; elementos) {
                                listaElementos.setValue(elementos);
                            }
                        });
                    }
                }
            </sc>
        </li>
    </ul>
</section>

<section>
    <h2>RecyclerView</h2>
    <p><w>RecyclerView</w> es un widget que permite mostrar y hacer <em>scroll</em> en una lista de elementos basados en grandes conjuntos de datos (o 
    datos que cambian frecuentemente).</p>

    <img src="img/list_mail.png">
    
    <p>Es una versión más avanzada y flexible del <w>ListView</w>.</p>

    <p>Permite mostrar los datos con 4 disposiciones diferentes:</p>
    <img src="img/layoutmanagers.png">

    <p>Para utilizar un RecyclerView son necesarios 3 componentes que funcionan conjuntamente para mostrar los datos:</p>

    <ul>
        <li><p><w>RecyclerView</w>: Es el contenedor principal para la interfaz de usuario.</p></li>
        <li><p><w>ViewHolder</w>: Es la plantilla para mostrar un elemento en el RecyclerView. Por ejemplo, si el RecyclerView ha de 
            mostrar una lista de productos, cada ViewHolder representa un único producto.</p></li>
        <li><p><w>Adapter</w>: El adaptador es el encargado de crear los ViewHolder, rellenarlos con los datos, y añadirlos al RecyclerView.</p></li>
    </ul>

    <img src="img/recyclercomponents.png">
</section>

<section>
    <h2>RecyclerView</h2>

    <p>Empezaremos programando el <w>RecyclerViewFragment</w> para que muestre en un <w>RecyclerView</w> 
        la lista de elementos (los del ArrayList).</p>

    <p>Será necesario poner a punto los 3 elementos:</p>
    <ul>
        <li>RecyclerView</li>
        <li>ViewHolder</li>
        <li>Adapter</li>
    </ul>


    <h3>RecyclerView</h3>

    <p>El ReciclerView es solamente el contenedor en el cual se van a mostrar los datos. Se añade al layout 
        en el cual se tiene que mostrar la lista (es decir, en el layout del RecyclerElementosFragment). 
    </p>

    <p>En principio el RecyclerView estará vació. Y será más adelante cuando lo rellenaremos (con código Java) con 
        los elementos del ArrayList.
    </p>

    <p>Lo único a tener en cuenta cuando se añade al layout es especificar la disposición de los elementos; se hace
        con el atributo <w>app:layoutManager</w> y en esta app utilizamos el <w>LinearLayoutManager</w>.
    </p>

    <scfile>
        fragment_recycler_elementos.xml
    </scfile>
    <sc xml data-line="2-6">
        &lt;FrameLayout ...&gt;
            &lt;androidx.recyclerview.widget.RecyclerView
                android:id=&quot;@+id/recycler&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;match_parent&quot;
                app:layoutManager=&quot;androidx.recyclerview.widget.LinearLayoutManager&quot; /&gt;
        &lt;/FrameLayout&gt;
    </sc>

    <h3>ViewHolder</h3>

    <p>El ViewHolder és la plantilla para mostrar un elemento de la lista. Se debe crear un fichero con la disposición 
        y una clase que habilite el ViewBinding.
    </p>

    <p>En el fichero de layout, ponemos un TextView para mostrar el <w>nombre</w> del elemento, y un RatingBar para la <w>valoracion</w>.</p>
    <scfile>
        viewholder_elemento.xml
    </scfile>
    <sc xml>
        &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
        &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:orientation=&quot;vertical&quot;&gt;

            &lt;TextView
                android:id=&quot;@+id/nombre&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;wrap_content&quot;
                android:textSize=&quot;32sp&quot; /&gt;
            &lt;RatingBar
                android:id=&quot;@+id/valoracion&quot;
                android:layout_width=&quot;wrap_content&quot;
                android:layout_height=&quot;wrap_content&quot;
                android:numStars=&quot;5&quot; /&gt;
        &lt;/LinearLayout&gt;
    </sc>

    <img src="img/rv_viewholderxml.png">

    <p>El TextView y el RatingBar los rellenaremos con los datos de un elemento de la lista. Para ello, 
        creamos una clase en la que guardaremos la variable <w>binding</w>, mediante la cual accederemos
        al TextView y al RatingBar</p>

    <p>Llamaremos a esta clase <w>ElementoViewHolder</w>. Debe extender de la clase <w>RecyclerView.ViewHolder</w>.</p>

    <scfile>
        RecyclerElementosFragment.java
    </scfile>
    <sc java data-line="4-11">
        public class RecyclerElementosFragment extends Fragment {
            // ...

            class ElementoViewHolder extends RecyclerView.ViewHolder {
                private final ViewholderElementoBinding binding;

                public ElementoViewHolder(ViewholderElementoBinding binding) {
                    super(binding.getRoot());
                    this.binding = binding;
                }
            }
        }
    </sc>

    <h3>Adapter</h3>

    <p>El <w>Adapter</w> será el encargado de crear las copias del ViewHolder, y rellenarlas con los datos del ArrayList.</p>

    <p>Para crear un Adaptador hay que extender la clase <w>RecyclerView.Adapter</w> y se debe especificar en el diamante <w>&lt;&gt;</w> 
    la clase del ViewHolder.</p>

    <p>Se deben anular 3 métodos:</p>

    <ul>
        <li><p><w>onCreateViewHolder()</w>: este método lo llama el RecyclerView cuando necesita una nueva copia del ViewHolder 
        para mostrar un elemento.</p></li>
        <li><p><w>onBindViewHolder()</w>: lo llama el RecyclerView para rellenar los datos de un ViewHolder en una posición determinada.</p></li>
        <li><p><w>getItemCount()</w>: lo llama el RecyclerView para saber cuántos elementos en total se van a mostrar.</p></li>
    </ul>

    <p>Por último, también es muy común hacer que el adaptador mantenga una referencia al ArrayList de los elementos. Para ello,
        declaramos una variable, y un método para establecerla. Un aspecto clave de este método es la llamada a <w>notifyDatasetChanged()</w>. 
        Este método notifica al RecyclerView que la lista ha cambiado y que debe volver a regenerar todos los ViewHolders.
    </p>

    <p>El código del adaptador queda así:</p>
    <scfile>
        RecyclerElementosFragment.java
    </scfile>
    <sc java data-line="4-32">
        public class RecyclerElementosFragment extends Fragment {
            // ...

            class ElementosAdapter extends RecyclerView.Adapter&lt;ElementoViewHolder&gt; {

                List&lt;Elemento&gt; elementos;
        
                @NonNull
                @Override
                public ElementoViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
                    return new ElementoViewHolder(ViewholderElementoBinding.inflate(getLayoutInflater(), parent, false));
                }
        
                @Override
                public void onBindViewHolder(@NonNull ElementoViewHolder holder, int position) {
        
                    Elemento elemento = elementos.get(position);
        
                    holder.binding.nombre.setText(elemento.nombre);
                    holder.binding.valoracion.setRating(elemento.valoracion);
                }
        
                @Override
                public int getItemCount() {
                    return elementos != null ? elementos.size() : 0;
                }
        
                public void establecerLista(List&lt;Elemento&gt; elementos){
                    this.elementos = elementos;
                    notifyDataSetChanged();
                }
            }
        }
    </sc>

    <p>Una vez creada la clase, hay que crear un objeto y asignarlo al RecyclerView con el método <w>setAdapter()</w>.</p>
    <scfile>
        RecyclerElementosFragment.java
    </scfile>
    <sc java data-line="8,9">
        public class RecyclerElementosFragment extends Fragment {
            // ...

            @Override
            public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
                // ...

                ElementosAdapter elementosAdapter = new ElementosAdapter();
                binding.recycler.setAdapter(elementosAdapter);
            }
            // ...
        }
    </sc>

    <p>El último paso solo es asignar la lista de elementos del adaptador (la variable <w>elementos</w>). La lista 
    la observaremos del ViewModel y la asignaremos llamando al método <w>establecerLista()</w>.</p>
    <scfile>
        RecyclerElementosFragment.java
    </scfile>
    <sc java data-line="8-13">
        public class RecyclerElementosFragment extends Fragment {
            // ...

            @Override
            public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
                // ...

                elementosViewModel.obtenerListaElementos().observe(getViewLifecycleOwner(), new Observer&lt;List&lt;Elemento&gt;&gt;() {
                    @Override
                    public void onChanged(List&lt;Elemento&gt; elementos) {
                        elementosAdapter.establecerLista(elementos);
                    }
                });
            }
            // ...
        }
    </sc>
</section>